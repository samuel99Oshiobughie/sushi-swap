{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useMemo, useReducer, useState } from 'react';\nimport { providers } from 'ethers';\nimport { useConfig } from '../../../hooks';\nimport { ReadonlyNetworksContext } from './context';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { networkStatesReducer } from './reducer';\nimport { useWindow } from '../../window';\nimport { isWebSocketProvider } from '../../../helpers';\nconst {\n  Provider,\n  StaticJsonRpcProvider\n} = providers;\n\nconst getProviderFromConfig = urlOrProviderOrProviderFunction => {\n  if (Provider.isProvider(urlOrProviderOrProviderFunction)) {\n    return urlOrProviderOrProviderFunction;\n  }\n\n  if (typeof urlOrProviderOrProviderFunction === 'function') {\n    return urlOrProviderOrProviderFunction();\n  }\n\n  return new StaticJsonRpcProvider(urlOrProviderOrProviderFunction);\n};\n\nexport const getProvidersFromConfig = readOnlyUrls => fromEntries(Object.entries(readOnlyUrls).map(_ref => {\n  let [chainId, urlOrProviderOrProviderFunction] = _ref;\n  return [chainId, getProviderFromConfig(urlOrProviderOrProviderFunction)];\n}));\nexport function ReadonlyNetworksProvider(_ref2) {\n  let {\n    providerOverrides = {},\n    children\n  } = _ref2;\n  const {\n    readOnlyUrls = {},\n    pollingInterval,\n    pollingIntervals\n  } = useConfig();\n  const {\n    isActive\n  } = useWindow();\n  const [providers, setProviders] = useState(() => Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides));\n  const [networkStates, dispatchNetworkState] = useReducer(networkStatesReducer, Object.assign({}, fromEntries(Object.keys(Object.assign(Object.assign({}, readOnlyUrls), providerOverrides)).map(chainId => [chainId, {\n    nonStaticCalls: 0\n  }]))));\n  const getPollingInterval = useCallback(chainId => {\n    var _a;\n\n    return (_a = pollingIntervals === null || pollingIntervals === void 0 ? void 0 : pollingIntervals[chainId]) !== null && _a !== void 0 ? _a : pollingInterval;\n  }, [pollingInterval, pollingIntervals]);\n  useEffect(() => {\n    setProviders(Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides));\n  }, Object.entries(readOnlyUrls).flat());\n  useEffect(() => {\n    for (const [chainId, {\n      nonStaticCalls\n    }] of Object.entries(networkStates)) {\n      const provider = providers[chainId];\n\n      if (provider) {\n        provider.polling = isActive && nonStaticCalls > 0;\n      }\n    }\n  }, [networkStates, isActive]);\n  useEffect(() => {\n    for (const [chainId, provider] of Object.entries(providers)) {\n      if (!isWebSocketProvider(provider)) {\n        provider.pollingInterval = getPollingInterval(Number(chainId));\n      }\n    }\n  }, [providers, getPollingInterval]);\n  const networks = useMemo(() => ({\n    providers,\n    updateNetworkState: dispatchNetworkState\n  }), [providers, dispatchNetworkState]);\n  return _jsx(ReadonlyNetworksContext.Provider, Object.assign({\n    value: networks\n  }, {\n    children: children\n  }));\n}","map":{"version":3,"sources":["../../../../../../src/providers/network/readonlyNetworks/provider.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useMemo, useReducer, useState } from 'react';\nimport { providers } from 'ethers';\nimport { useConfig } from '../../../hooks';\nimport { ReadonlyNetworksContext } from './context';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { networkStatesReducer } from './reducer';\nimport { useWindow } from '../../window';\nimport { isWebSocketProvider } from '../../../helpers';\nconst { Provider, StaticJsonRpcProvider } = providers;\nconst getProviderFromConfig = (urlOrProviderOrProviderFunction) => {\n    if (Provider.isProvider(urlOrProviderOrProviderFunction)) {\n        return urlOrProviderOrProviderFunction;\n    }\n    if (typeof urlOrProviderOrProviderFunction === 'function') {\n        return urlOrProviderOrProviderFunction();\n    }\n    return new StaticJsonRpcProvider(urlOrProviderOrProviderFunction);\n};\nexport const getProvidersFromConfig = (readOnlyUrls) => fromEntries(Object.entries(readOnlyUrls).map(([chainId, urlOrProviderOrProviderFunction]) => [\n    chainId,\n    getProviderFromConfig(urlOrProviderOrProviderFunction),\n]));\nexport function ReadonlyNetworksProvider({ providerOverrides = {}, children }) {\n    const { readOnlyUrls = {}, pollingInterval, pollingIntervals } = useConfig();\n    const { isActive } = useWindow();\n    const [providers, setProviders] = useState(() => (Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides)));\n    const [networkStates, dispatchNetworkState] = useReducer(networkStatesReducer, Object.assign({}, fromEntries(Object.keys(Object.assign(Object.assign({}, readOnlyUrls), providerOverrides)).map((chainId) => [chainId, { nonStaticCalls: 0 }]))));\n    const getPollingInterval = useCallback((chainId) => { var _a; return (_a = pollingIntervals === null || pollingIntervals === void 0 ? void 0 : pollingIntervals[chainId]) !== null && _a !== void 0 ? _a : pollingInterval; }, [\n        pollingInterval,\n        pollingIntervals,\n    ]);\n    useEffect(() => {\n        setProviders(Object.assign(Object.assign({}, getProvidersFromConfig(readOnlyUrls)), providerOverrides));\n    }, Object.entries(readOnlyUrls).flat());\n    useEffect(() => {\n        for (const [chainId, { nonStaticCalls }] of Object.entries(networkStates)) {\n            const provider = providers[chainId];\n            if (provider) {\n                provider.polling = isActive && nonStaticCalls > 0;\n            }\n        }\n    }, [networkStates, isActive]);\n    useEffect(() => {\n        for (const [chainId, provider] of Object.entries(providers)) {\n            if (!isWebSocketProvider(provider)) {\n                provider.pollingInterval = getPollingInterval(Number(chainId));\n            }\n        }\n    }, [providers, getPollingInterval]);\n    const networks = useMemo(() => ({\n        providers,\n        updateNetworkState: dispatchNetworkState,\n    }), [providers, dispatchNetworkState]);\n    return _jsx(ReadonlyNetworksContext.Provider, Object.assign({ value: networks }, { children: children }));\n}\n//# sourceMappingURL=provider.js.map"]},"metadata":{},"sourceType":"module"}