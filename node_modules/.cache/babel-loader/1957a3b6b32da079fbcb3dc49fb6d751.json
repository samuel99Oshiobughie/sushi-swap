{"ast":null,"code":"import { useContext, useEffect, useMemo } from 'react';\nimport { MultiChainStatesContext } from '../providers';\nimport { utils } from 'ethers';\n/**\n * A low-level function that makes multiple calls to specific methods of specific contracts and returns values or error if present.\n * The hook will cause the component to refresh when values change.\n *\n * Calls will be combined into a single multicall across all uses of {@link useChainCall}, {@link useChainCalls}, {@link useRawCall} and {@link useRawCalls}.\n * It is recommended to use {@link useCalls} where applicable instead of this method.\n * @public\n * @param calls List of calls, also see {@link RawCall}. Calls need to be in the same order across component renders.\n * @returns list of multicall calls. See {@link RawCallResult} and {@link useRawCall}.\n */\n\nexport function useRawCalls(calls) {\n  const {\n    dispatchCalls,\n    chains\n  } = useContext(MultiChainStatesContext);\n  useEffect(() => {\n    const filteredCalls = calls.filter(Boolean);\n    dispatchCalls({\n      type: 'ADD_CALLS',\n      calls: filteredCalls\n    });\n    return () => dispatchCalls({\n      type: 'REMOVE_CALLS',\n      calls: filteredCalls\n    });\n  }, [JSON.stringify(calls), dispatchCalls]);\n  return useMemo(() => calls.map(call => {\n    return call ? extractCallResult(chains, call) : undefined;\n  }), [JSON.stringify(calls), chains]);\n}\n/**\n * A low-level function that makes a call to a specific method of a specific contract and returns the value or error if present.\n * The hook will cause the component to refresh whenever a new block is mined and the value is changed.\n *\n * Calls will be combined into a single multicall across all uses of {@link useChainCall}, {@link useChainCalls}, {@link useRawCall} and {@link useRawCalls}.\n * It is recommended to use {@link useCall} where applicable instead of this method.\n *\n * @param call a single call, also see {@link RawCall}.\n *             A call can be Falsy, as it is important to keep the same ordering of hooks even if in a given render cycle\n *             and there might be not enough information to perform a call.\n * @public\n * @returns result of multicall call.\n *   The hook returns {@link RawCallResult} type.\n *   That is: `undefined` when call didn't return yet or object `{ success: boolean, value: string }` if it did,\n *   `success` - boolean indicating whether call was successful or not,\n *   `value` - encoded result when success is `true` or encoded error message when success is `false`.\n */\n\nexport function useRawCall(call) {\n  return useRawCalls([call])[0];\n}\n\nfunction extractCallResult(chains, call) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n\n  const chainId = call.chainId;\n\n  if (chainId !== undefined) {\n    const rawCallResult = (_d = (_c = (_b = (_a = chains[chainId]) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.state) === null || _c === void 0 ? void 0 : _c[call.address.toLowerCase()]) === null || _d === void 0 ? void 0 : _d[call.data];\n\n    if (rawCallResult) {\n      return rawCallResult;\n    }\n\n    const error = (_f = (_e = chains[chainId]) === null || _e === void 0 ? void 0 : _e.value) === null || _f === void 0 ? void 0 : _f.error;\n\n    if (error) {\n      const defaultErrorMessage = 'An error occurred';\n      const errorMessage = (_q = (_p = (_m = (_l = (_j = (_h = (_g = error.error) === null || _g === void 0 ? void 0 : _g.data) === null || _h === void 0 ? void 0 : _h.message) !== null && _j !== void 0 ? _j : (_k = error.error) === null || _k === void 0 ? void 0 : _k.message) !== null && _l !== void 0 ? _l : error.reason) !== null && _m !== void 0 ? _m : (_o = error.data) === null || _o === void 0 ? void 0 : _o.message) !== null && _p !== void 0 ? _p : error.message) !== null && _q !== void 0 ? _q : defaultErrorMessage;\n      const value = new utils.Interface(['function Error(string)']).encodeFunctionData('Error', [errorMessage]);\n      return {\n        success: false,\n        value\n      };\n    }\n  }\n}","map":{"version":3,"sources":["../../../../src/hooks/useRawCalls.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { useContext, useEffect, useMemo } from 'react';\nimport { MultiChainStatesContext } from '../providers';\nimport { utils } from 'ethers';\n/**\n * A low-level function that makes multiple calls to specific methods of specific contracts and returns values or error if present.\n * The hook will cause the component to refresh when values change.\n *\n * Calls will be combined into a single multicall across all uses of {@link useChainCall}, {@link useChainCalls}, {@link useRawCall} and {@link useRawCalls}.\n * It is recommended to use {@link useCalls} where applicable instead of this method.\n * @public\n * @param calls List of calls, also see {@link RawCall}. Calls need to be in the same order across component renders.\n * @returns list of multicall calls. See {@link RawCallResult} and {@link useRawCall}.\n */\nexport function useRawCalls(calls) {\n    const { dispatchCalls, chains } = useContext(MultiChainStatesContext);\n    useEffect(() => {\n        const filteredCalls = calls.filter(Boolean);\n        dispatchCalls({ type: 'ADD_CALLS', calls: filteredCalls });\n        return () => dispatchCalls({ type: 'REMOVE_CALLS', calls: filteredCalls });\n    }, [JSON.stringify(calls), dispatchCalls]);\n    return useMemo(() => calls.map((call) => {\n        return call ? extractCallResult(chains, call) : undefined;\n    }), [JSON.stringify(calls), chains]);\n}\n/**\n * A low-level function that makes a call to a specific method of a specific contract and returns the value or error if present.\n * The hook will cause the component to refresh whenever a new block is mined and the value is changed.\n *\n * Calls will be combined into a single multicall across all uses of {@link useChainCall}, {@link useChainCalls}, {@link useRawCall} and {@link useRawCalls}.\n * It is recommended to use {@link useCall} where applicable instead of this method.\n *\n * @param call a single call, also see {@link RawCall}.\n *             A call can be Falsy, as it is important to keep the same ordering of hooks even if in a given render cycle\n *             and there might be not enough information to perform a call.\n * @public\n * @returns result of multicall call.\n *   The hook returns {@link RawCallResult} type.\n *   That is: `undefined` when call didn't return yet or object `{ success: boolean, value: string }` if it did,\n *   `success` - boolean indicating whether call was successful or not,\n *   `value` - encoded result when success is `true` or encoded error message when success is `false`.\n */\nexport function useRawCall(call) {\n    return useRawCalls([call])[0];\n}\nfunction extractCallResult(chains, call) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n    const chainId = call.chainId;\n    if (chainId !== undefined) {\n        const rawCallResult = (_d = (_c = (_b = (_a = chains[chainId]) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.state) === null || _c === void 0 ? void 0 : _c[call.address.toLowerCase()]) === null || _d === void 0 ? void 0 : _d[call.data];\n        if (rawCallResult) {\n            return rawCallResult;\n        }\n        const error = (_f = (_e = chains[chainId]) === null || _e === void 0 ? void 0 : _e.value) === null || _f === void 0 ? void 0 : _f.error;\n        if (error) {\n            const defaultErrorMessage = 'An error occurred';\n            const errorMessage = (_q = (_p = (_m = (_l = (_j = (_h = (_g = error.error) === null || _g === void 0 ? void 0 : _g.data) === null || _h === void 0 ? void 0 : _h.message) !== null && _j !== void 0 ? _j : (_k = error.error) === null || _k === void 0 ? void 0 : _k.message) !== null && _l !== void 0 ? _l : error.reason) !== null && _m !== void 0 ? _m : (_o = error.data) === null || _o === void 0 ? void 0 : _o.message) !== null && _p !== void 0 ? _p : error.message) !== null && _q !== void 0 ? _q : defaultErrorMessage;\n            const value = new utils.Interface(['function Error(string)']).encodeFunctionData('Error', [errorMessage]);\n            return {\n                success: false,\n                value,\n            };\n        }\n    }\n}\n//# sourceMappingURL=useRawCalls.js.map"]},"metadata":{},"sourceType":"module"}