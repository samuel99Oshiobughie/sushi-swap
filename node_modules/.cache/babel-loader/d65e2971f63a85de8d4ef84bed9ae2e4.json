{"ast":null,"code":"import { encodeUint, bufPaddedLength, buffLength } from '../common';\nimport { ethersAbi, falseEncoded, trueEncoded } from './constants';\nconst selector = ethersAbi.getSighash('tryAggregate');\nexport function encodeCalls(start, calls) {\n  let res = start; // the first offset is calls.length * 0x20 because the first\n  // item of a dynamic array starts after all offsets\n\n  let dynamicOffset = calls.length * 0x20; // number of items in the array\n\n  res += encodeUint(calls.length);\n\n  for (const call of calls) {\n    // offset of the current call\n    res += encodeUint(dynamicOffset); // offset for the next call - current offset\n    // + length of the current call\n    // + space taken by the current offset\n    // + the first item in the next tuple - address for the next call\n    // + space taken by the offset for the next call data\n\n    dynamicOffset += 3 * 0x20 + bufPaddedLength(call[1]);\n  }\n\n  for (const call of calls) {\n    // address + calldata offset\n    dynamicOffset = 0x40;\n    res += '000000000000000000000000' + call[0].slice(2).toLowerCase();\n    res += encodeUint(dynamicOffset); // call data length\n\n    res += buffLength(call[1]).toString(16).padStart(64, '0'); // calldata\n\n    res += call[1].slice(2).padEnd(bufPaddedLength(call[1]) * 2, '0');\n  }\n\n  return res;\n}\nexport function encodeTryAggregate(b, calls) {\n  // function tryAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) public returns (tuple(bool success, bytes returnData)[])\n  let res = selector; // offset of the array is 0x40 because we need to\n  // encode requireSuccess flag and the offset itself\n\n  const dynamicOffset = 0x40;\n  res += b ? trueEncoded : falseEncoded;\n  res += encodeUint(dynamicOffset); // encode dynamic array of calls\n\n  return encodeCalls(res, calls);\n}","map":{"version":3,"sources":["../../../../../src/abi/multicall2/encoder.ts"],"names":[],"mappings":"AAAA,SAAS,UAAT,EAAqB,eAArB,EAAsC,UAAtC,QAAwD,WAAxD;AACA,SAAS,SAAT,EAAoB,YAApB,EAAkC,WAAlC,QAAqD,aAArD;AAEA,MAAM,QAAQ,GAAG,SAAS,CAAC,UAAV,CAAqB,cAArB,CAAjB;AAEA,OAAM,SAAU,WAAV,CAAsB,KAAtB,EAAqC,KAArC,EAA8D;EAClE,IAAI,GAAG,GAAG,KAAV,CADkE,CAElE;EACA;;EACA,IAAI,aAAa,GAAG,KAAK,CAAC,MAAN,GAAe,IAAnC,CAJkE,CAKlE;;EACA,GAAG,IAAI,UAAU,CAAC,KAAK,CAAC,MAAP,CAAjB;;EACA,KAAK,MAAM,IAAX,IAAmB,KAAnB,EAA0B;IACxB;IACA,GAAG,IAAI,UAAU,CAAC,aAAD,CAAjB,CAFwB,CAGxB;IACA;IACA;IACA;IACA;;IACA,aAAa,IAAI,IAAI,IAAJ,GAAW,eAAe,CAAC,IAAI,CAAC,CAAD,CAAL,CAA3C;EACD;;EAED,KAAK,MAAM,IAAX,IAAmB,KAAnB,EAA0B;IACxB;IACA,aAAa,GAAG,IAAhB;IACA,GAAG,IAAI,6BAA6B,IAAI,CAAC,CAAD,CAAJ,CAAQ,KAAR,CAAc,CAAd,EAAiB,WAAjB,EAApC;IACA,GAAG,IAAI,UAAU,CAAC,aAAD,CAAjB,CAJwB,CAMxB;;IACA,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,CAAD,CAAL,CAAV,CAAoB,QAApB,CAA6B,EAA7B,EAAiC,QAAjC,CAA0C,EAA1C,EAA8C,GAA9C,CAAP,CAPwB,CAQxB;;IACA,GAAG,IAAI,IAAI,CAAC,CAAD,CAAJ,CAAQ,KAAR,CAAc,CAAd,EAAiB,MAAjB,CAAwB,eAAe,CAAC,IAAI,CAAC,CAAD,CAAL,CAAf,GAA2B,CAAnD,EAAsD,GAAtD,CAAP;EACD;;EAED,OAAO,GAAP;AACD;AAED,OAAM,SAAU,kBAAV,CAA6B,CAA7B,EAAyC,KAAzC,EAAkE;EACtE;EACA,IAAI,GAAG,GAAG,QAAV,CAFsE,CAItE;EACA;;EACA,MAAM,aAAa,GAAG,IAAtB;EACA,GAAG,IAAI,CAAC,GAAG,WAAH,GAAiB,YAAzB;EACA,GAAG,IAAI,UAAU,CAAC,aAAD,CAAjB,CARsE,CAUtE;;EACA,OAAO,WAAW,CAAC,GAAD,EAAM,KAAN,CAAlB;AACD","sourceRoot":"","sourcesContent":["import { encodeUint, bufPaddedLength, buffLength } from '../common';\nimport { ethersAbi, falseEncoded, trueEncoded } from './constants';\nconst selector = ethersAbi.getSighash('tryAggregate');\nexport function encodeCalls(start, calls) {\n    let res = start;\n    // the first offset is calls.length * 0x20 because the first\n    // item of a dynamic array starts after all offsets\n    let dynamicOffset = calls.length * 0x20;\n    // number of items in the array\n    res += encodeUint(calls.length);\n    for (const call of calls) {\n        // offset of the current call\n        res += encodeUint(dynamicOffset);\n        // offset for the next call - current offset\n        // + length of the current call\n        // + space taken by the current offset\n        // + the first item in the next tuple - address for the next call\n        // + space taken by the offset for the next call data\n        dynamicOffset += 3 * 0x20 + bufPaddedLength(call[1]);\n    }\n    for (const call of calls) {\n        // address + calldata offset\n        dynamicOffset = 0x40;\n        res += '000000000000000000000000' + call[0].slice(2).toLowerCase();\n        res += encodeUint(dynamicOffset);\n        // call data length\n        res += buffLength(call[1]).toString(16).padStart(64, '0');\n        // calldata\n        res += call[1].slice(2).padEnd(bufPaddedLength(call[1]) * 2, '0');\n    }\n    return res;\n}\nexport function encodeTryAggregate(b, calls) {\n    // function tryAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) public returns (tuple(bool success, bytes returnData)[])\n    let res = selector;\n    // offset of the array is 0x40 because we need to\n    // encode requireSuccess flag and the offset itself\n    const dynamicOffset = 0x40;\n    res += b ? trueEncoded : falseEncoded;\n    res += encodeUint(dynamicOffset);\n    // encode dynamic array of calls\n    return encodeCalls(res, calls);\n}\n//# sourceMappingURL=encoder.js.map"]},"metadata":{},"sourceType":"module"}