{"ast":null,"code":"import { utils } from 'ethers';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function warnOnInvalidCall(call) {\n  if (!call) {\n    return;\n  }\n\n  const {\n    contract,\n    method,\n    args\n  } = call;\n  console.warn(`Invalid contract call: address=${contract.address} method=${method} args=${args}`);\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function encodeCallData(call, chainId) {\n  let queryParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a;\n\n  if (!call) {\n    return undefined;\n  }\n\n  const {\n    contract,\n    method,\n    args\n  } = call;\n\n  if (!contract.address || !method) {\n    warnOnInvalidCall(call);\n    return undefined;\n  }\n\n  try {\n    const isStatic = (_a = queryParams.isStatic) !== null && _a !== void 0 ? _a : queryParams.refresh === 'never';\n    const refreshPerBlocks = typeof queryParams.refresh === 'number' ? queryParams.refresh : undefined;\n    return {\n      address: contract.address,\n      data: contract.interface.encodeFunctionData(method, args),\n      chainId,\n      isStatic,\n      refreshPerBlocks\n    };\n  } catch (_b) {\n    warnOnInvalidCall(call);\n    return undefined;\n  }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function getUniqueActiveCalls(requests) {\n  const unique = [];\n  const used = {};\n\n  for (const request of requests) {\n    if (!used[`${request.address.toLowerCase()}${request.data}${request.chainId}`]) {\n      unique.push(request);\n      used[`${request.address.toLowerCase()}${request.data}${request.chainId}`] = true;\n    }\n  }\n\n  return unique;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function getCallsForUpdate(requests, options) {\n  const callsForUpdate = [];\n\n  for (const request of requests) {\n    if (options) {\n      if (options.chainId && options.chainId !== request.chainId) {\n        continue;\n      }\n\n      if (request.isStatic && request.lastUpdatedBlockNumber !== undefined) {\n        continue;\n      }\n\n      const currentBlock = options.blockNumber;\n\n      if (currentBlock && request.lastUpdatedBlockNumber && request.refreshPerBlocks) {\n        if (currentBlock < request.lastUpdatedBlockNumber + request.refreshPerBlocks) {\n          continue;\n        }\n      }\n    }\n\n    callsForUpdate.push(request);\n  }\n\n  return callsForUpdate;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function decodeCallResult(call, result) {\n  if (!result || !call) {\n    return undefined;\n  }\n\n  const {\n    value,\n    success\n  } = result;\n\n  try {\n    if (success) {\n      return {\n        value: call.contract.interface.decodeFunctionResult(call.method, value),\n        error: undefined\n      };\n    } else {\n      const errorMessage = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', value)[0];\n      return {\n        value: undefined,\n        error: new Error(errorMessage)\n      };\n    }\n  } catch (error) {\n    return {\n      value: undefined,\n      error: error\n    };\n  }\n}","map":{"version":3,"sources":["../../../../src/helpers/calls.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { utils } from 'ethers';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function warnOnInvalidCall(call) {\n    if (!call) {\n        return;\n    }\n    const { contract, method, args } = call;\n    console.warn(`Invalid contract call: address=${contract.address} method=${method} args=${args}`);\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function encodeCallData(call, chainId, queryParams = {}) {\n    var _a;\n    if (!call) {\n        return undefined;\n    }\n    const { contract, method, args } = call;\n    if (!contract.address || !method) {\n        warnOnInvalidCall(call);\n        return undefined;\n    }\n    try {\n        const isStatic = (_a = queryParams.isStatic) !== null && _a !== void 0 ? _a : queryParams.refresh === 'never';\n        const refreshPerBlocks = typeof queryParams.refresh === 'number' ? queryParams.refresh : undefined;\n        return {\n            address: contract.address,\n            data: contract.interface.encodeFunctionData(method, args),\n            chainId,\n            isStatic,\n            refreshPerBlocks,\n        };\n    }\n    catch (_b) {\n        warnOnInvalidCall(call);\n        return undefined;\n    }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getUniqueActiveCalls(requests) {\n    const unique = [];\n    const used = {};\n    for (const request of requests) {\n        if (!used[`${request.address.toLowerCase()}${request.data}${request.chainId}`]) {\n            unique.push(request);\n            used[`${request.address.toLowerCase()}${request.data}${request.chainId}`] = true;\n        }\n    }\n    return unique;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getCallsForUpdate(requests, options) {\n    const callsForUpdate = [];\n    for (const request of requests) {\n        if (options) {\n            if (options.chainId && options.chainId !== request.chainId) {\n                continue;\n            }\n            if (request.isStatic && request.lastUpdatedBlockNumber !== undefined) {\n                continue;\n            }\n            const currentBlock = options.blockNumber;\n            if (currentBlock && request.lastUpdatedBlockNumber && request.refreshPerBlocks) {\n                if (currentBlock < request.lastUpdatedBlockNumber + request.refreshPerBlocks) {\n                    continue;\n                }\n            }\n        }\n        callsForUpdate.push(request);\n    }\n    return callsForUpdate;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function decodeCallResult(call, result) {\n    if (!result || !call) {\n        return undefined;\n    }\n    const { value, success } = result;\n    try {\n        if (success) {\n            return {\n                value: call.contract.interface.decodeFunctionResult(call.method, value),\n                error: undefined,\n            };\n        }\n        else {\n            const errorMessage = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', value)[0];\n            return {\n                value: undefined,\n                error: new Error(errorMessage),\n            };\n        }\n    }\n    catch (error) {\n        return {\n            value: undefined,\n            error: error,\n        };\n    }\n}\n//# sourceMappingURL=calls.js.map"]},"metadata":{},"sourceType":"module"}